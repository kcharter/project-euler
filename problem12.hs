module Main where

{-

Problem 12:

The sequence of triangle numbers is generated by adding the natural
numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7
= 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

-}

{-

Solution:

First, recall that Sum(1,n) = 1 + 2 + ... + n = n(n+1)/2. That is, the
nth triangle number is n(n+1)/2. So it's very easy to generate a long
prefix of the triangle numbers.  

Now, suppose we can compute the prime factorization of a number 'm',

 (p1, n1), ..., (pk, nk)

where p1, ..., pk are distinct primes and n1, ..., nk are the
exponents for those primes. Then we can compute the number of factors
of 'm'. Observe that each unique factor of 'm' corresponds to a unique
choice of exponents

 0 <= m1 <= n1, ..., 0 <= mk <= nk

for the primes p1, ..., pk. Counting the zero exponents, there are

 (n1+1) * ... * (nk+1)

different possible choices of exponents, and so this is the number of
factors of 'm', including 1 and 'm' itself.

Now, finding the prime factorization of a number quickly gets harder
as the number gets larger. The final observation is that we don't need
to compute n*(n+1)/2 in order to find its prime factorization. It's
sufficient to compute the prime factorizations of 'n' and 'n+1'.

In fact, observe that 'n' and 'n+1' cannot have any prime factors in
common, because otherwise we would have

 n+1 = n + k*p  for some prime 'p' and some k >= 1

But every prime 'p' is greater than 1, so 'k*p' is likewise greater
than 1 and we have a contradiction.

Therefore, if D(m) is the number of divisors of 'm', we can conclude
that

 D(n*(n+1)/2) =    D(n/2) * D(n+1)    if 'n' is even
              OR   D(n) * D((n+1)/2)  if 'n' is odd

That is, to find the number of divisors of the triangle numbers, it is
sufficient to find the number of divisors of 'n/2' for each even 'n',
and 'n' for each odd 'n', until we find the triangle number with over
500 divisors.

-}

import Data.List (foldl')
import Sieve

primeFactors :: Integer -> [(Integer, Int)]
primeFactors n = collectFactors $ factors n [] (head primes) (tail primes)
  where factors n sofar candidate rest =
          if candidate > n
          then reverse sofar
          else if n `mod` candidate == 0
               then factors (n `div` candidate) (candidate:sofar) candidate rest
               else factors n sofar (head rest) (tail rest)
        primes = sieve
        collectFactors = foldr collect []
          where collect n [] = [(n,1)]
                collect n sofar@((m,e):rest) =
                  if n == m then (m,e+1):rest else (n,1):sofar

divisorCount :: Integer -> Int
divisorCount = product . map ((1+) . snd) . primeFactors

triangleNumbersWithDivisorCounts :: [(Integer, Int)]
triangleNumbersWithDivisorCounts = generateFrom eoWithDivisorCount
  where generateFrom ((n,c):rest@((n',c'):others)) =
          (n*n' `div` 2, c*c'):generateFrom rest

-- We use eoWithDivisorCount in order to avoid computing the prime
-- factors of the same number more than once. When this solution is
-- compiled with '-O2' it finishes in about 0.4 seconds on my laptop.

eoWithDivisorCount :: [(Integer, Int)]
eoWithDivisorCount = iterate next (1,1)
  where next (n,_) = let n' = n + 1
                         m = if even n' then n' `div` 2 else n'
                     in (n', divisorCount m)

main :: IO ()
main = print $ with500Divisors
  where with500Divisors = head $ dropWhile ((500>) . snd) $ triangleNumbersWithDivisorCounts

